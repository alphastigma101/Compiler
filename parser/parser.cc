#include <parser.h>
template struct std::shared_ptr<Variant<Binary, Unary, Grouping, Literal>>; // define the underlying of ExprTypes
ExprTypes<Binary, Unary, Grouping, Literal> parser::expr;
logTable<Map<String, Vector<String>>> parser::logs_;
template<class T>
Token parseError<T>::token;
template<class T>
String parseError<T>::message;
/** ---------------------------------------------------------------------------------------------------------------------------------------
 * @brief Used for calling the other rules for processing the tokens generated by the scanner
 *
 * @details This method represents the binary section in the grammar in parser.h. It uses variant which is known as a union type safe. 
    It will recrusive call itself functioning just like the grammar layout in parser.h
 * @details If it doesn't find a match it will step out of the loop and return back to expression(). 
    Otherwise, it will keep storing the calls into expr and push the res to a vector for farther processing 
 *
 * @return comparision()
 *
 * ---------------------------------------------------------------------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::equality()  {
    // Recursion left !=
    auto expr_ = comparison();
    while (match(TokenType::BANG_EQUAL, TokenType::EQUAL_EQUAL)) {
        const Token op = previous();
        // Recursion right ==
        auto right = comparison();
        expr = std::make_shared<ExprVariant>(Binary(expr_, op, right)); // initialize it with Binary instance
        auto res = compressedAstTree(idx, std::string("Binary"), expr);
        nodes.push_back(std::move(res));
        idx++;
    }
    return expr;
}
/** --------------------------------------------------------------------------
 * @brief Called from the equality() method. Will call term() and start trying to create the Binary Nodes
 *
 * @return term()
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::comparison()  {
    auto expr_ = term();
    while (match(TokenType::GREATER, TokenType::GREATER_EQUAL, TokenType::LESS, TokenType::LESS_EQUAL)) {
        const Token op = previous();
        auto right = term();
        expr = std::make_shared<ExprVariant>(Binary(expr_, op, right));
        auto res = compressedAstTree(idx, std::string("Binary"), expr);
        nodes.push_back(std::move(res));
        idx++;
    }
    return expr;
}
/** --------------------------------------------------------------------------
 * @brief Gets called from comparison and searches through the tokens for minus or plus
 *
 * @return expr 
 *
 * @details expr is a shared_ptr wrapped with variant that holds Binary, Unary, Grouping, and Literal instances
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::term() {
    auto expr_ = factor();
    while (match(TokenType::MINUS, TokenType::PLUS)) {
        const Token op = previous();
        auto right = factor();
        expr = std::make_shared<ExprVariant>(Binary(expr_, op, right)); // initialize it with Binary instance
        auto res = compressedAstTree(idx, std::string("Binary"), expr);
        nodes.push_back(std::move(res));
        idx++;
    }
    return expr;
}
/** --------------------------------------------------------------------------
 * @brief Gets called from term(). Searches the tokens for slash or star which are multiplication/division
 *
 * @return expr
 *
 * @details expr is a shared_ptr wrapper that wraps around variants that hold Binary, Unary, Grouping, and Literal instances
 * @details Also, grouping class is not needed if you do not want to parse the TokenTypes even farther.
   Ex: Factor can handle the () but Grouping is needed so it can get the nested () expression as it's own 
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::factor() {
    auto expr_ = unary();
    while (match(TokenType::SLASH, TokenType::STAR, TokenType::MODULO)) {
        const Token op = previous();
        auto right = unary();
        expr = std::make_shared<ExprVariant>(Binary(expr_, op, right));
        auto res = compressedAstTree(idx, std::string("Binary"), expr);
        nodes.push_back(std::move(res));
        idx++;
    }
    return expr;
}
/** --------------------------------------------------------------------------
 * @brief Gets called from factor(). Searches for != and minus tokens
 *
 * @return Either expr or primary()
 *
 * @details expr is a shared_ptr that wraps around a variant that holds Binary, Unary, Grouping, and Literal instances
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::unary() {
    if (match(TokenType::BANG, TokenType::MINUS)) {
        const Token op = previous();
        auto right = unary();
        expr = std::make_shared<ExprVariant>(Unary(right, op));
        auto res = compressedAstTree(idx, std::string("Unary"), right);
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    return primary();
}
/** --------------------------------------------------------------------------
 * @brief Gets called from unary(). 
 *
 * @return expr after going through a series of if statements or will through an exception of '(' or ')'  
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::primary() {
    if (match(TokenType::FALSE)) {
        expr = std::make_shared<ExprVariant>(Literal(false)); // initialize it with Literal instance
        auto res = compressedAstTree(idx, std::string("Literal"), expr);
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    if (match(TokenType::TRUE)) {
        expr = std::make_shared<ExprVariant>(Literal(true));
        auto res = compressedAstTree(idx, std::string("Literal"), expr);
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    if (match(TokenType::NIL)) {
        expr = std::make_shared<ExprVariant>(Literal(NULL));
        auto res = compressedAstTree(idx, std::string("Literal"), expr);
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    if (match(TokenType::NUMBER, TokenType::STRING)) {
        expr = std::make_shared<ExprVariant>(Literal(previous().getLiteral()));
        auto res = compressedAstTree(idx, std::string("Literal"), expr); 
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    if (match(TokenType::LEFT_PAREN)) {
        auto expr_ = expression();
        consume(TokenType::RIGHT_PAREN, "Expect ')' after expression.");
        expr = std::make_shared<ExprVariant>(Grouping(expr_));
        auto res = compressedAstTree(idx, std::string("Grouping"), expr); 
        nodes.push_back(std::move(res));
        idx++;
        return expr;
    }
    parseError<parser> pp(peek(), "Expect expression.");
    throw pp;
}
/** --------------------------------------------------------------------------
 * @brief Expands into equality to start the recrusion
 *
 * @details It becomes equality's caller
 *
 * @return equality()
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::expression() { return equality(); }
/** --------------------------------------------------------------------------
 * @brief Calls in expression to start the parsing sequence by following the grammar
 *
 * @details catches any exceptions that were thrown during run time 
 *
 * @return Either return from all the recrusive calls if nothing was thrown, otherwise return null 
 * --------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::parse() {
    try { return expression();}
    catch (parseError<parser>& e) { 
        std::cout << e.error() << std::endl;
        return NULL; 
    }
}
/** ----------------------------------------------------------------------------- 
 * @brief An identifier is a name of something. Generallly something that is not wrapped around in quotes
 * 
 * @details For example, variable name, function name, class name, if statements, structs, etc.
 * 
 * ------------------------------------------------------------------------------
*/
ExprTypes<Binary, Unary, Grouping, Literal> parser::identifier() {
    // Rules usually require recrusion 
    // Think of Calling a funciton again as if you're looking ahead 
    // LR is look ahead right 
    // LL is look ahead left
    // LAR occurs when the rule aka the funciton gets called multuple times. Typically in a loop
    // LAL is the same thing but it looks ahead to the left
    // https://www.gnu.org/software/bison/manual/bison.html#Grammar-File 
    // 
    if(match(TokenType::IDENTIFIER)) {
        auto expr_ = arguments(); // Look to the right

    }
    
    return primary(); // indentifier has a literal 
}
/**---------------------------------------------------------------
 * 
 * 
 */
ExprTypes<Binary, Unary, Grouping, Literal> parser::arguments() {
    auto expr_ = arguments(); // Look to the left
    while(TokenType::IDENTIFIER, TokenType::LEFT_BRACE, TokenType::RIGHT_BRACE, TokenType::LEFT_PAREN, TokenType::RIGHT_PAREN) {
        auto right = arguments(); // Look ahead to the right

    }

    return expr;
}
// Additional rules go above this line
//
//
//

// Error handling
/**
 * @brief custom exception thrower that throws syntax errors if detected
 * 
 * @return Calls in the report helper method
*/
std::string parser::error() {
    if (token.getType() == TokenType::END_OF_FILE) { return report(token.getLine(), " at end", message);}
    return report(token.getLine(), " at '" + token.getLexeme() + "'", message);
}
/** --------------------------------------------------------------------------------------
 * @brief A method that calls in logging to store the error that occured
 * 
 * @param line: The line it occured 
 * @param where: The literal 
 * @param message: The error message
 * 
 * @return Returns the error that occured
 * -------------------------------------------------------------------------------------- 
*/            
std::string parser::report(int line, const std::string where, const std::string message) throw() {
    std::string err = "[line " + std::to_string(line) + "] Error" + where +  ": " + message;
    //std::cout << "[line " <<  line << "] Error" << where << ": " + message;
    logging<parser> logs(logs_, err); // Keep the logs updated throughout the whole codebase
    logs.update();
    logs.write();
    logs.rotate();
    return err;
}
